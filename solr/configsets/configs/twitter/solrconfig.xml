<?xml version="1.0" encoding="UTF-8" ?>
<config>

  <!-- required for ICU -->
  <lib dir="${solr.install.dir}/contrib/analysis-extras/lib/" />
  <lib dir="${solr.install.dir}/contrib/analysis-extras/lucene-libs/" />
<!--  TODO: add date router jar-->

  <luceneMatchVersion>8.4.1</luceneMatchVersion>
  <dataDir>${solr.data.dir:}</dataDir>
  <directoryFactory name="DirectoryFactory"
                    class="${solr.directoryFactory:solr.NRTCachingDirectoryFactory}"/>
  <codecFactory class="solr.SchemaCodecFactory"/>

  <!-- BOP: We prefer to have the schema declared, not manipulated with an API. -->
<!--  <schemaFactory class="ClassicIndexSchemaFactory"/>-->
  <indexConfig>

    <!-- BOP Use '4' instead of 10 to keep segment count low, albeit with more merging. -->
    <mergePolicyFactory class="org.apache.solr.index.TieredMergePolicyFactory">
      <int name="maxMergeAtOnce">4</int>
      <int name="segmentsPerTier">4</int>
    </mergePolicyFactory>

    <!-- mostly for the realtime shard's benefit -->
    <mergedSegmentWarmer class="org.apache.lucene.index.SimpleMergedSegmentWarmer"/>


    <lockType>${solr.lock.type:native}</lockType>
  </indexConfig>

  <updateHandler class="solr.DirectUpdateHandler2">
    <updateLog>
      <str name="dir">${solr.ulog.dir:}</str>
      <int name="numVersionBuckets">${solr.ulog.numVersionBuckets:65536}</int>
    </updateLog>

    <autoCommit>
      <maxTime>${solr.autoCommit.maxTime:60000}</maxTime>
      <maxDocs>${solr.autoCommit.maxDocs:100000}</maxDocs>
      <openSearcher>false</openSearcher>
    </autoCommit>

    <autoSoftCommit>
      <maxTime>${solr.autoSoftCommit.maxTime:30000}</maxTime>
    </autoSoftCommit>

  </updateHandler>

  <requestHandler name="/update" class="solr.UpdateRequestHandler">
    <lst name="defaults">
<!--      <str name="processor">bopUrpScript</str>  this urp runs first, in BOP, not needed here -->
      <str name="update.chain">${solr.update.chain:dateSharded}</str>

      <!-- config for DateShardingURPFactory: -->
      <str name="router.field">CreatedAt</str>
      <str name="shardMaxAge">+1MONTH</str>
      <str name="docMaxAge">/MONTH-30MONTHS</str>
      <str name="TZ">UTC</str><!-- or US/EASTERN. DO NOT CHANGE -->
    </lst>
  </requestHandler>

<!--  used for testing?-->
  <updateRequestProcessorChain name="standaloneTesting">
    <processor class="solr.LogUpdateProcessorFactory" />
    <processor class="solr.RunUpdateProcessorFactory" />
  </updateRequestProcessorChain>

  <updateRequestProcessorChain name="dateSharded">
    <processor class="edu.harvard.gis.hhypermap.bop.solrplugins.DateShardingURPFactory" />
    <!-- If we want to re-index, either use a new collection, or comment out this URP: -->
    <processor class="solr.SkipExistingDocumentsProcessorFactory"/><!-- skips if id exits-->
    <processor class="solr.DistributedUpdateProcessorFactory"/>
    <processor class="solr.IgnoreFieldUpdateProcessorFactory">
      <str name="fieldName">_route_</str>
    </processor>
    <!-- DWS: TOO noisy <processor class="solr.LogUpdateProcessorFactory" />-->
    <processor class="solr.RunUpdateProcessorFactory" />
  </updateRequestProcessorChain>


<!--  <updateProcessor name="bopUrpScript" class="solr.StatelessScriptUpdateProcessorFactory">-->
<!--    <str name="script">update-script.js</str>-->
<!--    <lst name="params">-->
<!--      <str name="conditionField">sentiment_pos</str>-->
<!--      <str name="sourceCopyField">coord</str>-->
<!--      <str name="destCopyField">coordSentimentPos_hm</str>-->
<!--    </lst>-->
<!--  </updateProcessor>-->

  <query>
    <maxBooleanClauses>${solr.max.booleanClauses:1024}</maxBooleanClauses>
 <!-- BOP: maxRamMB=375 would be nice to use assuming ~8 shards per node, and 3GB (of 6GB total
      heap) available and ~1/30th of billion docs per replica.
      However some shards are much larger and would have fewer entries, leading to
      cache misses that are very detrimental to overall performance. Unfortunately the cache size
      can't be configured for the entire node. So I want each shard to have
      a fixed cache entry size assuming that each node has a roughly similar total number of
      documents across its shards.
      Solr 6.5+ will re-use a shared instance of any query that matches everything.  In the BOP. the
      most filter cache entries will be from time faceting which will tend to populate each shard's
      filter cache with entries that will match everything or nothing; and such entries are
      essentially free (and BTW maxRamMB is unaware of value sharing).  If this were not the case,
      we might suggest size=90 but due to this we can size this much larger (thankfully). -->
<!--      <filterCache class="solr.FastLRUCache"-->
<!--                 size="256"-->
<!--                 autowarmCount="45"/>-->
    <filterCache class="solr.FastLRUCache"
                 size="512"
                 initialSize="512"
                 autowarmCount="45"/> <!--  autowarmCount was 0 -->

<!--    <queryResultCache class="solr.LRUCache"-->
<!--                      maxRamMB="20"-->
<!--                      autowarmCount="2"/>-->
    <queryResultCache class="solr.LRUCache"
                      size="512"
                      initialSize="512"
                      autowarmCount="2"/> <!--  autowarmCount was 0 -->


<!--    <documentCache class="solr.LRUCache"-->
<!--                   size="500"-->
<!--                   autowarmCount="0"/>-->
    <documentCache class="solr.LRUCache"
                   size="512"
                   initialSize="512"
                   autowarmCount="0"/>

    <!-- custom cache currently used by block join -->
    <cache name="perSegFilter"
           class="solr.search.LRUCache"
           size="10"
           initialSize="0"
           autowarmCount="10"
           regenerator="solr.NoOpRegenerator" />

        <!-- BOP: we always want the whole thing, basically -->
    <enableLazyFieldLoading>false</enableLazyFieldLoading> <!--   was true -->

    <queryResultWindowSize>20</queryResultWindowSize>
    <queryResultMaxDocsCached>200</queryResultMaxDocsCached>
    <useColdSearcher>false</useColdSearcher>

<!--  no listeners in bop  -->
<!--        <listener event="newSearcher" class="solr.QuerySenderListener">-->
<!--      <arr name="queries">-->
<!--        &lt;!&ndash;-->
<!--           <lst><str name="q">solr</str><str name="sort">price asc</str></lst>-->
<!--           <lst><str name="q">rocks</str><str name="sort">weight asc</str></lst>-->
<!--          &ndash;&gt;-->
<!--      </arr>-->
<!--    </listener>-->
<!--    <listener event="firstSearcher" class="solr.QuerySenderListener">-->
<!--      <arr name="queries">-->
<!--        &lt;!&ndash;-->
<!--        <lst>-->
<!--          <str name="q">static firstSearcher warming in solrconfig.xml</str>-->
<!--        </lst>-->
<!--        &ndash;&gt;-->
<!--      </arr>-->
<!--    </listener>-->

  </query>

  <requestDispatcher>
<!--  enable remote streaming for convenience  -->
    <requestParsers enableRemoteStreaming="true"
                    enableStreamBody="true"
                    multipartUploadLimitInKB="2048000"
                    formdataUploadLimitInKB="2048"
                    addHttpRequestToContext="false"/>
    <httpCaching never304="true" />
  </requestDispatcher>

  <requestHandler name="/select" class="solr.SearchHandler">
    <!-- default values for query parameters can be specified, these
         will be overridden by parameters in the request
      -->
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <int name="rows">10</int>
      <str name="wt">json</str>
    </lst>
  </requestHandler>

  <initParams path="/update/**,/query,/select,/spell">
    <lst name="defaults">
<!--      <str name="df">_text_</str>-->
      <str name="df">Text</str>
    </lst>
  </initParams>

  <requestHandler name="/select/bop/search" class="${solr.searchHandler:solr.SearchHandler}">
    <lst name="defaults">
      <str name="fl">id,created_at,coord,user_name,text,
        sentiment_pos,
        geoadmin_admin2,geoadmin_admin2_txt,
        geoadmin_us_census_tract,
        geoadmin_us_ma_census_block,geoadmin_us_ma_census_block_townName</str>
    </lst>
  </requestHandler>
  <requestHandler name="/select/bop/export" class="${solr.searchHandler:solr.SearchHandler}">
    <lst name="defaults">
      <str name="fl">id,
        sentiment_pos,
        geoadmin_admin2,geoadmin_admin2_txt,
        geoadmin_us_census_tract,
        geoadmin_us_ma_census_block,geoadmin_us_ma_census_block_townName</str>
    </lst>
  </requestHandler>

  <initParams name="bop" path="/select/bop/*">
    <lst name="defaults">
      <str name="echoParams">none</str>

      <str name="defType">edismax</str>
      <str name="q.alt">*:*</str>
      <str name="qf">text hashtags mentions</str>
      <!-- as of Lucene 5.5, dismax "mm" is broken. This config below enables a default of
       AND but lets a user use OR to explicitly get OR. SOLR-8812 -->
      <str name="mm">0%</str>
      <str name="q.op">AND</str>

      <int name="facet.mincount">1</int> <!-- although client sends 0 for time faceting -->
      <!-- https://issues.apache.org/jira/browse/SOLR-9152 & SOLR-8988   in 6.1 -->
      <bool name="facet.distrib.mco">true</bool>
      <!-- until we know we want to either "pay" the high RAM cost of uninverting, or develop
       a docValues approach (some custom dev work Solr-side is necessary), use enum -->
      <str name="f.text.facet.method">enum</str>
      <int name="facet.enum.cache.minDF">1000000</int>

      <!--<bool name="shards.tolerant">true</bool>-->
    </lst>
  </initParams>

  <!-- Search Components

       Search components are registered to SolrCore and used by
       instances of SearchHandler (which can access them by name)

       By default, the following components are available:

       <searchComponent name="query"     class="solr.QueryComponent" />
       <searchComponent name="facet"     class="solr.FacetComponent" />
       <searchComponent name="mlt"       class="solr.MoreLikeThisComponent" />
       <searchComponent name="highlight" class="solr.HighlightComponent" />
       <searchComponent name="stats"     class="solr.StatsComponent" />
       <searchComponent name="debug"     class="solr.DebugComponent" />

       Default configuration in a requestHandler would look like:

       <arr name="components">
         <str>query</str>
         <str>facet</str>
         <str>mlt</str>
         <str>highlight</str>
         <str>stats</str>
         <str>debug</str>
       </arr>

       If you register a searchComponent to one of the standard names,
       that will be used instead of the default.

       To insert components before or after the 'standard' components, use:

       <arr name="first-components">
         <str>myFirstComponentName</str>
       </arr>

       <arr name="last-components">
         <str>myLastComponentName</str>
       </arr>

       NOTE: The component registered with the name "debug" will
       always be executed after the "last-components"

     -->

  <!-- Terms Component

       http://wiki.apache.org/solr/TermsComponent

       A component to return terms and document frequency of those
       terms
    -->
  <searchComponent name="terms" class="solr.TermsComponent"/>

  <!-- A request handler for demonstrating the terms component -->
  <requestHandler name="/terms" class="solr.SearchHandler" startup="lazy">
    <lst name="defaults">
      <bool name="terms">true</bool>
      <bool name="distrib">false</bool>
    </lst>
    <arr name="components">
      <str>terms</str>
    </arr>
  </requestHandler>

  <updateProcessor class="solr.UUIDUpdateProcessorFactory" name="uuid"/>
  <updateProcessor class="solr.RemoveBlankFieldUpdateProcessorFactory" name="remove-blank"/>
  <updateProcessor class="solr.FieldNameMutatingUpdateProcessorFactory" name="field-name-mutating">
    <str name="pattern">[^\w-\.]</str>
    <str name="replacement">_</str>
  </updateProcessor>
  <updateProcessor class="solr.ParseBooleanFieldUpdateProcessorFactory" name="parse-boolean"/>
  <updateProcessor class="solr.ParseLongFieldUpdateProcessorFactory" name="parse-long"/>
  <updateProcessor class="solr.ParseDoubleFieldUpdateProcessorFactory" name="parse-double"/>
  <updateProcessor class="solr.ParseDateFieldUpdateProcessorFactory" name="parse-date">
    <arr name="format">
      <str>yyyy-MM-dd['T'[HH:mm[:ss[.SSS]][z</str>
      <str>yyyy-MM-dd['T'[HH:mm[:ss[,SSS]][z</str>
      <str>yyyy-MM-dd HH:mm[:ss[.SSS]][z</str>
      <str>yyyy-MM-dd HH:mm[:ss[,SSS]][z</str>
      <str>[EEE, ]dd MMM yyyy HH:mm[:ss] z</str>
      <str>EEEE, dd-MMM-yy HH:mm:ss z</str>
      <str>EEE MMM ppd HH:mm:ss [z ]yyyy</str>
    </arr>
  </updateProcessor>

  <!-- The update.autoCreateFields property can be turned to false to disable schemaless mode -->
  <updateRequestProcessorChain name="add-unknown-fields-to-the-schema" default="${update.autoCreateFields:true}"
           processor="uuid,remove-blank,field-name-mutating,parse-boolean,parse-long,parse-double,parse-date">
    <processor class="solr.LogUpdateProcessorFactory"/>
    <processor class="solr.DistributedUpdateProcessorFactory"/>
    <processor class="solr.RunUpdateProcessorFactory"/>
  </updateRequestProcessorChain>

</config>
